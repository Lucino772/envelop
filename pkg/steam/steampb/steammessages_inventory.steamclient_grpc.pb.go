// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.27.1
// source: steammessages_inventory.steamclient.proto

package steampb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InventoryClient is the client API for Inventory service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InventoryClient interface {
	GetInventory(ctx context.Context, in *CInventory_GetInventory_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	ExchangeItem(ctx context.Context, in *CInventory_ExchangeItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	GetEligiblePromoItemDefIDs(ctx context.Context, in *CInventory_GetEligiblePromoItemDefIDs_Request, opts ...grpc.CallOption) (*CInventory_GetEligiblePromoItemDefIDs_Response, error)
	AddPromoItem(ctx context.Context, in *CInventory_AddItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	SafeModifyItems(ctx context.Context, in *CInventory_ModifyItems_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	ConsumePlaytime(ctx context.Context, in *CInventory_ConsumePlaytime_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	ConsumeItem(ctx context.Context, in *CInventory_ConsumeItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	DevGenerateItem(ctx context.Context, in *CInventory_AddItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	DevSetNextDrop(ctx context.Context, in *CInventory_DevSetNextDrop_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	SplitItemStack(ctx context.Context, in *CInventory_SplitItemStack_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	CombineItemStacks(ctx context.Context, in *CInventory_CombineItemStacks_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	GetItemDefMeta(ctx context.Context, in *CInventory_GetItemDefMeta_Request, opts ...grpc.CallOption) (*CInventory_GetItemDefMeta_Response, error)
	GetUserPurchaseInfo(ctx context.Context, in *CInventory_GetUserPurchaseInfo_Request, opts ...grpc.CallOption) (*CInventory_GetUserPurchaseInfo_Response, error)
	PurchaseInit(ctx context.Context, in *CInventory_PurchaseInit_Request, opts ...grpc.CallOption) (*CInventory_PurchaseInit_Response, error)
	PurchaseFinalize(ctx context.Context, in *CInventory_PurchaseFinalize_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
	InspectItem(ctx context.Context, in *CInventory_InspectItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error)
}

type inventoryClient struct {
	cc grpc.ClientConnInterface
}

func NewInventoryClient(cc grpc.ClientConnInterface) InventoryClient {
	return &inventoryClient{cc}
}

func (c *inventoryClient) GetInventory(ctx context.Context, in *CInventory_GetInventory_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/GetInventory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) ExchangeItem(ctx context.Context, in *CInventory_ExchangeItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/ExchangeItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) GetEligiblePromoItemDefIDs(ctx context.Context, in *CInventory_GetEligiblePromoItemDefIDs_Request, opts ...grpc.CallOption) (*CInventory_GetEligiblePromoItemDefIDs_Response, error) {
	out := new(CInventory_GetEligiblePromoItemDefIDs_Response)
	err := c.cc.Invoke(ctx, "/Inventory/GetEligiblePromoItemDefIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) AddPromoItem(ctx context.Context, in *CInventory_AddItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/AddPromoItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) SafeModifyItems(ctx context.Context, in *CInventory_ModifyItems_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/SafeModifyItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) ConsumePlaytime(ctx context.Context, in *CInventory_ConsumePlaytime_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/ConsumePlaytime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) ConsumeItem(ctx context.Context, in *CInventory_ConsumeItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/ConsumeItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) DevGenerateItem(ctx context.Context, in *CInventory_AddItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/DevGenerateItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) DevSetNextDrop(ctx context.Context, in *CInventory_DevSetNextDrop_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/DevSetNextDrop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) SplitItemStack(ctx context.Context, in *CInventory_SplitItemStack_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/SplitItemStack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) CombineItemStacks(ctx context.Context, in *CInventory_CombineItemStacks_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/CombineItemStacks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) GetItemDefMeta(ctx context.Context, in *CInventory_GetItemDefMeta_Request, opts ...grpc.CallOption) (*CInventory_GetItemDefMeta_Response, error) {
	out := new(CInventory_GetItemDefMeta_Response)
	err := c.cc.Invoke(ctx, "/Inventory/GetItemDefMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) GetUserPurchaseInfo(ctx context.Context, in *CInventory_GetUserPurchaseInfo_Request, opts ...grpc.CallOption) (*CInventory_GetUserPurchaseInfo_Response, error) {
	out := new(CInventory_GetUserPurchaseInfo_Response)
	err := c.cc.Invoke(ctx, "/Inventory/GetUserPurchaseInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) PurchaseInit(ctx context.Context, in *CInventory_PurchaseInit_Request, opts ...grpc.CallOption) (*CInventory_PurchaseInit_Response, error) {
	out := new(CInventory_PurchaseInit_Response)
	err := c.cc.Invoke(ctx, "/Inventory/PurchaseInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) PurchaseFinalize(ctx context.Context, in *CInventory_PurchaseFinalize_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/PurchaseFinalize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryClient) InspectItem(ctx context.Context, in *CInventory_InspectItem_Request, opts ...grpc.CallOption) (*CInventory_Response, error) {
	out := new(CInventory_Response)
	err := c.cc.Invoke(ctx, "/Inventory/InspectItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryServer is the server API for Inventory service.
// All implementations must embed UnimplementedInventoryServer
// for forward compatibility
type InventoryServer interface {
	GetInventory(context.Context, *CInventory_GetInventory_Request) (*CInventory_Response, error)
	ExchangeItem(context.Context, *CInventory_ExchangeItem_Request) (*CInventory_Response, error)
	GetEligiblePromoItemDefIDs(context.Context, *CInventory_GetEligiblePromoItemDefIDs_Request) (*CInventory_GetEligiblePromoItemDefIDs_Response, error)
	AddPromoItem(context.Context, *CInventory_AddItem_Request) (*CInventory_Response, error)
	SafeModifyItems(context.Context, *CInventory_ModifyItems_Request) (*CInventory_Response, error)
	ConsumePlaytime(context.Context, *CInventory_ConsumePlaytime_Request) (*CInventory_Response, error)
	ConsumeItem(context.Context, *CInventory_ConsumeItem_Request) (*CInventory_Response, error)
	DevGenerateItem(context.Context, *CInventory_AddItem_Request) (*CInventory_Response, error)
	DevSetNextDrop(context.Context, *CInventory_DevSetNextDrop_Request) (*CInventory_Response, error)
	SplitItemStack(context.Context, *CInventory_SplitItemStack_Request) (*CInventory_Response, error)
	CombineItemStacks(context.Context, *CInventory_CombineItemStacks_Request) (*CInventory_Response, error)
	GetItemDefMeta(context.Context, *CInventory_GetItemDefMeta_Request) (*CInventory_GetItemDefMeta_Response, error)
	GetUserPurchaseInfo(context.Context, *CInventory_GetUserPurchaseInfo_Request) (*CInventory_GetUserPurchaseInfo_Response, error)
	PurchaseInit(context.Context, *CInventory_PurchaseInit_Request) (*CInventory_PurchaseInit_Response, error)
	PurchaseFinalize(context.Context, *CInventory_PurchaseFinalize_Request) (*CInventory_Response, error)
	InspectItem(context.Context, *CInventory_InspectItem_Request) (*CInventory_Response, error)
	mustEmbedUnimplementedInventoryServer()
}

// UnimplementedInventoryServer must be embedded to have forward compatible implementations.
type UnimplementedInventoryServer struct {
}

func (UnimplementedInventoryServer) GetInventory(context.Context, *CInventory_GetInventory_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInventory not implemented")
}
func (UnimplementedInventoryServer) ExchangeItem(context.Context, *CInventory_ExchangeItem_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExchangeItem not implemented")
}
func (UnimplementedInventoryServer) GetEligiblePromoItemDefIDs(context.Context, *CInventory_GetEligiblePromoItemDefIDs_Request) (*CInventory_GetEligiblePromoItemDefIDs_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEligiblePromoItemDefIDs not implemented")
}
func (UnimplementedInventoryServer) AddPromoItem(context.Context, *CInventory_AddItem_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPromoItem not implemented")
}
func (UnimplementedInventoryServer) SafeModifyItems(context.Context, *CInventory_ModifyItems_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SafeModifyItems not implemented")
}
func (UnimplementedInventoryServer) ConsumePlaytime(context.Context, *CInventory_ConsumePlaytime_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsumePlaytime not implemented")
}
func (UnimplementedInventoryServer) ConsumeItem(context.Context, *CInventory_ConsumeItem_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsumeItem not implemented")
}
func (UnimplementedInventoryServer) DevGenerateItem(context.Context, *CInventory_AddItem_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DevGenerateItem not implemented")
}
func (UnimplementedInventoryServer) DevSetNextDrop(context.Context, *CInventory_DevSetNextDrop_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DevSetNextDrop not implemented")
}
func (UnimplementedInventoryServer) SplitItemStack(context.Context, *CInventory_SplitItemStack_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SplitItemStack not implemented")
}
func (UnimplementedInventoryServer) CombineItemStacks(context.Context, *CInventory_CombineItemStacks_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CombineItemStacks not implemented")
}
func (UnimplementedInventoryServer) GetItemDefMeta(context.Context, *CInventory_GetItemDefMeta_Request) (*CInventory_GetItemDefMeta_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetItemDefMeta not implemented")
}
func (UnimplementedInventoryServer) GetUserPurchaseInfo(context.Context, *CInventory_GetUserPurchaseInfo_Request) (*CInventory_GetUserPurchaseInfo_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserPurchaseInfo not implemented")
}
func (UnimplementedInventoryServer) PurchaseInit(context.Context, *CInventory_PurchaseInit_Request) (*CInventory_PurchaseInit_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurchaseInit not implemented")
}
func (UnimplementedInventoryServer) PurchaseFinalize(context.Context, *CInventory_PurchaseFinalize_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurchaseFinalize not implemented")
}
func (UnimplementedInventoryServer) InspectItem(context.Context, *CInventory_InspectItem_Request) (*CInventory_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectItem not implemented")
}
func (UnimplementedInventoryServer) mustEmbedUnimplementedInventoryServer() {}

// UnsafeInventoryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InventoryServer will
// result in compilation errors.
type UnsafeInventoryServer interface {
	mustEmbedUnimplementedInventoryServer()
}

func RegisterInventoryServer(s grpc.ServiceRegistrar, srv InventoryServer) {
	s.RegisterService(&Inventory_ServiceDesc, srv)
}

func _Inventory_GetInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_GetInventory_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).GetInventory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/GetInventory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).GetInventory(ctx, req.(*CInventory_GetInventory_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_ExchangeItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_ExchangeItem_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).ExchangeItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/ExchangeItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).ExchangeItem(ctx, req.(*CInventory_ExchangeItem_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_GetEligiblePromoItemDefIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_GetEligiblePromoItemDefIDs_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).GetEligiblePromoItemDefIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/GetEligiblePromoItemDefIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).GetEligiblePromoItemDefIDs(ctx, req.(*CInventory_GetEligiblePromoItemDefIDs_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_AddPromoItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_AddItem_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).AddPromoItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/AddPromoItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).AddPromoItem(ctx, req.(*CInventory_AddItem_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_SafeModifyItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_ModifyItems_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).SafeModifyItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/SafeModifyItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).SafeModifyItems(ctx, req.(*CInventory_ModifyItems_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_ConsumePlaytime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_ConsumePlaytime_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).ConsumePlaytime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/ConsumePlaytime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).ConsumePlaytime(ctx, req.(*CInventory_ConsumePlaytime_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_ConsumeItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_ConsumeItem_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).ConsumeItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/ConsumeItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).ConsumeItem(ctx, req.(*CInventory_ConsumeItem_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_DevGenerateItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_AddItem_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).DevGenerateItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/DevGenerateItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).DevGenerateItem(ctx, req.(*CInventory_AddItem_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_DevSetNextDrop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_DevSetNextDrop_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).DevSetNextDrop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/DevSetNextDrop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).DevSetNextDrop(ctx, req.(*CInventory_DevSetNextDrop_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_SplitItemStack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_SplitItemStack_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).SplitItemStack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/SplitItemStack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).SplitItemStack(ctx, req.(*CInventory_SplitItemStack_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_CombineItemStacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_CombineItemStacks_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).CombineItemStacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/CombineItemStacks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).CombineItemStacks(ctx, req.(*CInventory_CombineItemStacks_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_GetItemDefMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_GetItemDefMeta_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).GetItemDefMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/GetItemDefMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).GetItemDefMeta(ctx, req.(*CInventory_GetItemDefMeta_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_GetUserPurchaseInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_GetUserPurchaseInfo_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).GetUserPurchaseInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/GetUserPurchaseInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).GetUserPurchaseInfo(ctx, req.(*CInventory_GetUserPurchaseInfo_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_PurchaseInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_PurchaseInit_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).PurchaseInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/PurchaseInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).PurchaseInit(ctx, req.(*CInventory_PurchaseInit_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_PurchaseFinalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_PurchaseFinalize_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).PurchaseFinalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/PurchaseFinalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).PurchaseFinalize(ctx, req.(*CInventory_PurchaseFinalize_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inventory_InspectItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventory_InspectItem_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServer).InspectItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inventory/InspectItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServer).InspectItem(ctx, req.(*CInventory_InspectItem_Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Inventory_ServiceDesc is the grpc.ServiceDesc for Inventory service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Inventory_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Inventory",
	HandlerType: (*InventoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInventory",
			Handler:    _Inventory_GetInventory_Handler,
		},
		{
			MethodName: "ExchangeItem",
			Handler:    _Inventory_ExchangeItem_Handler,
		},
		{
			MethodName: "GetEligiblePromoItemDefIDs",
			Handler:    _Inventory_GetEligiblePromoItemDefIDs_Handler,
		},
		{
			MethodName: "AddPromoItem",
			Handler:    _Inventory_AddPromoItem_Handler,
		},
		{
			MethodName: "SafeModifyItems",
			Handler:    _Inventory_SafeModifyItems_Handler,
		},
		{
			MethodName: "ConsumePlaytime",
			Handler:    _Inventory_ConsumePlaytime_Handler,
		},
		{
			MethodName: "ConsumeItem",
			Handler:    _Inventory_ConsumeItem_Handler,
		},
		{
			MethodName: "DevGenerateItem",
			Handler:    _Inventory_DevGenerateItem_Handler,
		},
		{
			MethodName: "DevSetNextDrop",
			Handler:    _Inventory_DevSetNextDrop_Handler,
		},
		{
			MethodName: "SplitItemStack",
			Handler:    _Inventory_SplitItemStack_Handler,
		},
		{
			MethodName: "CombineItemStacks",
			Handler:    _Inventory_CombineItemStacks_Handler,
		},
		{
			MethodName: "GetItemDefMeta",
			Handler:    _Inventory_GetItemDefMeta_Handler,
		},
		{
			MethodName: "GetUserPurchaseInfo",
			Handler:    _Inventory_GetUserPurchaseInfo_Handler,
		},
		{
			MethodName: "PurchaseInit",
			Handler:    _Inventory_PurchaseInit_Handler,
		},
		{
			MethodName: "PurchaseFinalize",
			Handler:    _Inventory_PurchaseFinalize_Handler,
		},
		{
			MethodName: "InspectItem",
			Handler:    _Inventory_InspectItem_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "steammessages_inventory.steamclient.proto",
}

// InventoryClientClient is the client API for InventoryClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InventoryClientClient interface {
	NotifyNewItems(ctx context.Context, in *CInventoryClient_NewItems_Notification, opts ...grpc.CallOption) (*NoResponse, error)
}

type inventoryClientClient struct {
	cc grpc.ClientConnInterface
}

func NewInventoryClientClient(cc grpc.ClientConnInterface) InventoryClientClient {
	return &inventoryClientClient{cc}
}

func (c *inventoryClientClient) NotifyNewItems(ctx context.Context, in *CInventoryClient_NewItems_Notification, opts ...grpc.CallOption) (*NoResponse, error) {
	out := new(NoResponse)
	err := c.cc.Invoke(ctx, "/InventoryClient/NotifyNewItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryClientServer is the server API for InventoryClient service.
// All implementations must embed UnimplementedInventoryClientServer
// for forward compatibility
type InventoryClientServer interface {
	NotifyNewItems(context.Context, *CInventoryClient_NewItems_Notification) (*NoResponse, error)
	mustEmbedUnimplementedInventoryClientServer()
}

// UnimplementedInventoryClientServer must be embedded to have forward compatible implementations.
type UnimplementedInventoryClientServer struct {
}

func (UnimplementedInventoryClientServer) NotifyNewItems(context.Context, *CInventoryClient_NewItems_Notification) (*NoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyNewItems not implemented")
}
func (UnimplementedInventoryClientServer) mustEmbedUnimplementedInventoryClientServer() {}

// UnsafeInventoryClientServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InventoryClientServer will
// result in compilation errors.
type UnsafeInventoryClientServer interface {
	mustEmbedUnimplementedInventoryClientServer()
}

func RegisterInventoryClientServer(s grpc.ServiceRegistrar, srv InventoryClientServer) {
	s.RegisterService(&InventoryClient_ServiceDesc, srv)
}

func _InventoryClient_NotifyNewItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CInventoryClient_NewItems_Notification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryClientServer).NotifyNewItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/InventoryClient/NotifyNewItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryClientServer).NotifyNewItems(ctx, req.(*CInventoryClient_NewItems_Notification))
	}
	return interceptor(ctx, in, info, handler)
}

// InventoryClient_ServiceDesc is the grpc.ServiceDesc for InventoryClient service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InventoryClient_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "InventoryClient",
	HandlerType: (*InventoryClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifyNewItems",
			Handler:    _InventoryClient_NotifyNewItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "steammessages_inventory.steamclient.proto",
}
